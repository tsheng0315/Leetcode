## 1512. Number of Good Pairs

Given an array of integers nums.

A pair (i,j) is called good if ```nums[i] == nums[j]``` and ```i < j```.

Return the number of good pairs.

### Example 1:
```
Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
```


### My code:
```python
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        count =0
        nums_length=len(nums)
        for i in range(nums_length):
            for j in range(i+1,nums_length):
                if nums[i]=nums[j]:
                    count+=1
        return count
``` 

### Dom: dict+ pointer; key->number, value->frequency

```python
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        count_by_number={}
        for n in nums:
            if n not in count_by_number:     # n appeared for the first time
                count_by_number[n]=1
            else:
                count_by_number[n]+=1
        result=0
        value=count_by_number.values()
        for v in value:
            result+=v*(v-1)//2
        return result
```

### online one
```python
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        return sum(v * (v - 1) // 2 for v in collections.Counter(nums).values())  # dict.values()  return value
```    

```python   
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        
        return sum(v * (v - 1) // 2 for key,v in collections.Counter(nums).items())  # dict.items() return key and value 
```    


### Dom's version

Construct a mapping between each number and the indexes at which that number appears within the supplied array. For each index i, determine the number of pairs of indices ```(i, j)``` which exists such that ```i < j``` and ```nums[i] == nums[j]```.

```python
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        no_good_pairs = 0
        
        index_by_value = {}
        for i, v in enumerate(nums):
            if v not in index_by_value:
                index_by_value[v] = []
            index_by_value[v].append(i)
            
        for i, v in enumerate(nums):
            same_value_indices = index_by_value[v]
            no_good_pairs += len(same_value_indices[same_value_indices.index(i) + 1:])
                    
        return no_good_pairs
```


This can be simplified by, for each index i expanded, removing that index from the index_by_value mapping:



```python
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        no_good_pairs = 0
        
        index_by_value = {}
        for i, v in enumerate(nums):
            if v not in index_by_value:
                index_by_value[v] = []
            index_by_value[v].append(i)
            
        for i, v in enumerate(nums):
            index_by_value[v].pop(0)  #pop the first element from the list.
            no_good_pairs += len(index_by_value[v])
                    
        return no_good_pairs
```        

The use of a singly linked-list, instead of an array based Python list, to store the indices at which each number exists within the supplied array would further improved performance.
